Pesquisa Linear x binária, Ordenamento

Considere duas estruturas básicas em python: list e array

Ver exemplo de tempo com list e array


Ver [[Exemplos]] de entrada/saída função  mexe.py


Como elas armazenam na memória?

# Exercício:
Criar uma pilha usando array com operações básicas (Quais são elas?)

Utilizando seed=123 (Quais pacotes?), crie um programa que adicione 4 elementos aleatórios entre 1 e 100,  retire 2 elementos e adicione mais 4 elementos aleatórios.
## passo1

```python
import numpy as np
import random

def add(x):
    pass
def remove():
    pass

n=5                      # tamanho inicial
P=np.zeros(n, dtype=int)

print(P)
random.seed(123)

```

Completar as funções, quais operações extra?

## passo2

```python
def add(x):
    global k
    P[k]=x
    k=k+1
    

def remove():
    global k
    k=k-1
    P[k]=0
    pass

def init(n):
    global k
    k=0
    P=np.zeros(n, dtype=int)
    return P

def get(i):
    pass

def set(i,x):
    pass

n=5                      # tamanho inicial
k=0
P=np.zeros(n, dtype=int)

print(P)
random.seed(123)

for i in range(4):
    x=random.randint(1,100)
    add(x)
    print(P)

for i in range(2):
    remove()
    print(P)

for i in range(4):
    x=random.randint(1,100)
    add(x)
    print(P)
```

Podemos criar essa Fila como uma classe.  
Ver [Orientação a Objeto](Orientação%20a%20Objeto.md)


# Classe Fila

Quase tudo pronto. Definir a classe e salvar num arquivo fila.py

```python
from numpy import zeros

class Pilha:
class Pilha:
    def __init__(self,n):
        self.k=0
        self.n=n
        self.P=zeros(self.n, dtype=int)

    def add(self,x):
        if self.k<self.n:
            self.P[self.k]=x
            self.k=self.k+1
        else:
            print("         :( passou do limite  ")
    

    def remove(self):
        if self.k>0:
            self.k=self.k-1
            self.P[self.k]=0
        else:
            print("         :( tá vazio  ")

    def get(self,i):
        return self.P[i]

    def set(self,i,x):
        self.P[i]=x

    def __str__(self):
        res=f'Pilha= {self.P}'
        return res
```

Exemplo de uso:

```python
 
import Pilha
import random
    
n=5                      # tamanho inicial
P=Pilha(n)

print(P)
random.seed(123)

for i in range(4):
    x=random.randint(1,100)
    P.add(x)
    print(P)

print( P.get(2) )
P.set(2,99)

for i in range(6):
    P.remove()
    print(P)

for i in range(4):
    x=random.randint(1,100)
    P.add(x)
    print(P)
```



Podemos redefinir o set e o get para usar os colchetes colocando dentro da classe. Isso é um exemplo de ==operator overload==

```python
    def __getitem__(self, chave):  # redefine a leitura com P[] 
        return self.P(chave)

    def __setitem__(self, chave, valor):  # Redefine a escrita usando []
        self.P[chave] = valor

# exemplo
print(P[3]) 
P[3] = 98
 
```




código com visualização...

# Pesquisa Linear

```python
def busca(x,L):
	n=len(L)
	for k in range(n):
	    if L[k]==x:
			#print(f'Achei {x} em {k})
			return k      
	return 'não achei'


n=50
P=Pilha(n)
for i in range(40):
    x=random.randint(1,100)
    P.add(x)

x = 33
k = busca(x,P)
```


# Pesquisa Binária

Qual a condição em `x` para que se use a busca binária?

```python
def busca_binaria(x,L):
	achou=False
	n=len(L)
	ini = 1
	fim = n
	while ~achou and i<f:
		m=int( i+f )/2
		if L[m]==x:
			achou=True
			return m
		if L[m]<x:
			fim=m-1
		else
			ini=m+1
	return 'não achei'

```


# Algoritmos de Busca

Algoritmo de busca de uma string dentro de outra.

Sejam as string  x com comprimento n e y com comprimento m, encontre a posição de y em x.



## Algoritmo de busca força bruta


1. sem fase de pré-processamento
2. espaço extra de armazenamento constante    
3. sempre desloca a janela de busca por exatamente 1 posição à direita    
4. as comparações podem ser feitas em qualquer ordem    
5. fase de busca com complexidade: O(mn)
6. número de comparações de caracteres: O(2n)   
7. comparações são repetidas

```python
def FB(x,y):
    n=len(x)
    m=len(y)
    for j in range(0,n-m):
        i=0
        while (i<m) and (x[i]==y[i+j]):
            i=i+1
        if i>=m:
            print(j)
```

## Algoritmo de busca Morris-Pratt (MP)

Características:

1. realiza as comparações da esquerda para a direita
    
2. fase de pré-processamento com complexidade espacial e temporal
    
3. fase de busca com complexidade ; independente do tamanho do alfabeto
    
4. realiza no máximo comparações
    
5. atraso na comparação: limitado a
    
6. guarda a informação de quais caracteres já foram comparados, deixando de fazer algumas comparações, por serem desnecessárias (uso de deslocamentos calculados adequadamente), usando uma tabela contendo m+1 elementos
    

proc MP(string x,y; int m,n)

// busca ocorrências da string x (com m caracteres)

// dentro da string y (de n) caracteres

1. int i,j,Tabela[0:m-1]
    
2. cria_tabela_MP(x,m,Tabela) // Pré-processamento: O(m)
    
3. i:=0 // Busca (usando a tabela): O(m+n)
    
4. j:=0
    
5. enquanto j<n faça
    
6. enquanto (i>-1) & (x[i]/=y[j]) faça
    
7. i:=Tabela[i]
    
8. fim enquanto
    
9. i:=i+1
    
10. j:=j+1
    
11. se i>=m então
    
12. imprima j-i
    
13. i:=Tabela[i]
    
14. fim se
    
15. fim enquanto
    

fim proc

  

proc cria_tabela_MP(string x; int m; ref int T[0:m-1])

1. int i, j
    
2. i:=0
    
3. T[0]:=-1
    
4. j:=-1
    
5. enquanto i<m faça
    
6. enquanto (j>-1) & (x[i]/=x[j]) faça
    
7. j:=T[j]
    
8. fim enquanto
    
9. i:=i+1
    
10. j:=j+1
    
11. T[i]:=j
    
12. fim enquanto
    

fim proc


## Algoritmo de busca (KMP)

Características:

1. realiza as comparações da esquerda para a direita
    
2. fase de pré-processamento com complexidade espacial e temporal
    
3. fase de busca com complexidade ; independente do tamanho do alfabeto
    
4. atraso na comparação: limitado a , onde (razão áurea)
    
5. melhoramento do algoritmo MP, com deslocamentos calculados de forma mais precisa.
    

proc KMP(string x,y; int m,n)

// busca ocorrências da string x (com m caracteres)

// dentro da string y (de n) caracteres

1. int i,j,Tabela[0:m-1]
    
2. cria_tabela_KMP(x,m,Tabela) // Pré-processamento: O(m)
    
3. i:=0 // Busca (usando a tabela): O(m+n)
    
4. j:=0
    
5. enquanto j<n faça
    
6. enquanto (i>-1) & (x[i]/=y[j]) faça
    
7. i:=Tabela[i]
    
8. fim enquanto
    
9. i:=i+1
    
10. j:=j+1
    
11. se i>=m então
    
12. imprima j-i
    
13. i:=Tabela[i]
    
14. fim se
    
15. fim enquanto
    

fim proc

  

proc cria_tabela_KMP(string x; int m; ref int T[0:m-1])

// cria tabela T de ocorrências dos caracteres de x

1. int i,j
    
2. i:=0
    
3. T[0]:=-1
    
4. j:=-1
    
5. enquanto i<m faça
    
6. enquanto (j>-1) & (x[i]/=x[j]) faça
    
7. j:=T[j]
    
8. fim enquanto
    
9. i:=i+1
    
10. j:=j+1
    
11. se (i<m) & (x[i]==x[j]) então
    
12. T[i]:=T[j]
    
13. senão
    
14. T[i]:=j
    
15. fim se
    
16. fim enquanto
    

fim proc






# Ordenamento



Próximo [[S3]]